from urllib.parse import urljoin

from typing import Dict, TypedDict, Any, List, Optional, Iterator

from dlt.sources.helpers import requests
from dlt.common import json
from dlt.common.jsonpath import TJsonPath

from .types import UNSET
from .utils import extract_nested_data
from ._base import APICredentials


class ParamInfo(TypedDict):
    name: str
    types: List[str]
    explode: bool
    style: Optional[str]


class TParameterMap(TypedDict):
    """
    Mapping to get the original parameter names from resource python arguments.

    Python arguments sometimes need to be escaped so may not match the original
    query/path/header/cookie parameter.
    """

    path: Optional[Dict[str, ParamInfo]]
    query: Optional[Dict[str, ParamInfo]]
    header: Optional[Dict[str, ParamInfo]]
    cookie: Optional[Dict[str, ParamInfo]]


def build_query_param(info: ParamInfo, value: Any) -> Dict[str, Any]:
    """Serialize the query param according to
    https://swagger.io/docs/specification/serialization /
    """
    if value is None or value is UNSET:
        return {}
    name = info["name"]
    style = info.get("style")
    explode = info["explode"]
    if isinstance(value, list):
        serialized_list = [json.dumps(v) for v in value]
        if info["explode"]:
            return {name: serialized_list}  # Translates to repeated params, e.g. ?id=1&id=2&id=3
        return {name: ",".join(serialized_list)}
    elif isinstance(value, dict):
        serialized_obj = {k: json.dumps(v) for k, v in value.items()}
        if explode:
            if style == "deepObject":  # ?id[role]=admin&id[name]=Alex
                return {f"{name}[{k}": v for k, v in serialized_obj.items()}
            # Assume form
            return {k: v for k, v in serialized_obj.items()}
        # Unexploded form e.g. id=role,admin,name,Alex
        return {name: ",".join([f"{k},{v}" for k, v in value.items()])}
    # Other types sent as json strings
    return {name: json.dumps(value)}


def fetch_json(
    base_url: str,
    endpoint_url: str,
    parameters: Dict[str, Any],
    parameter_map: TParameterMap,
    credentials: Optional[APICredentials] = None,
) -> Any:
    # Build absolute URL with path parameters
    # TODO: Path params may need serialized, explode, etc
    path_params = {
        mapped_param["name"]: parameters[python_name]
        for python_name, mapped_param in parameter_map.get("path", {}).items()
    }
    abs_url = urljoin(base_url, endpoint_url).format_map(path_params)

    request_args: Dict[str, Any] = {}
    if credentials:
        request_args.update(credentials.to_http_params())

    query_params = {}
    for python_name, param_info in parameter_map.get("query", {}).items():
        query_params.update(build_query_param(param_info, parameters[python_name]))

    request_args["query"].update(query_params)

    # TODO: Header/cookie params

    response = requests.get(abs_url, params=query_params)
    return response.json()


def fetch_list_items(
    base_url: str,
    endpoint_url: str,
    parameters: Dict[str, Any],
    parameter_map: TParameterMap,
    data_json_path: Optional[TJsonPath] = None,
    credentials: Optional[APICredentials] = None,
) -> Iterator[Any]:
    data = fetch_json(base_url, endpoint_url, parameters, parameter_map, credentials=credentials)
    yield from extract_nested_data(data, data_json_path)
